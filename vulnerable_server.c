/**
 *  vulnerable_server.c
 *  
 *  
 *  This server is based on code written by Abhijeet Rastogi available at the url 
 *  https://blog.abhi.host/blog/2010/04/15/very-simple-http-server-writen-in-c/
 *  
 *  This is a very simple server. The default port is 10000.  
 *  On connecting the user will be provided with the socket id for the connection and 
 *  prompted to enter the length of their message.  
 *  If the message length exceeds MAX_SIZE then the server will let the user know 
 *  and interaction will cease.
 *  If the message length is less than MAX_SIZE then the server will ask the user to
 *  enter their message.  The user's message will be copied from an initial buffer to 
 *  a local buffer (of length MAX_SIZE) and then interaction with the server will cease.   
 * 
 *  Notes: 
 *  - The following command was used to compile this file 
 *  	gcc -g -no-pie -fno-stack-protector -o server vulnerable_server.c
 *  
 *  - execstack was not run (so program stack was not executable)
 *  - ASLR was enabled i.e. /proc/sys/kernel/randomize_va_space set to 2
 */

#include<stdio.h>
#include<string.h>
#include<stdlib.h>
#include<unistd.h>
#include<sys/types.h>
#include<sys/stat.h>
#include<sys/socket.h>
#include<arpa/inet.h>
#include<netdb.h>
#include<signal.h>
#include<fcntl.h>
#include<errno.h>

#define CONNMAX 1000
#define MAX_SIZE 128
#define INPUT_BUF 4096

char *ROOT;
int listenfd, clients[CONNMAX];

void error(char *);
void startServer(char *);
void respond(int);

int main(int argc, char* argv[])
{
    struct sockaddr_in clientaddr;
    socklen_t addrlen;
    char c;
    
    //Default Value PORT=10000
    char PORT[6];
    ROOT = getenv("PWD");
    strcpy(PORT,"10000");
    
    int slot=0;
    
    //Parsing the command line arguments
    while ((c = getopt (argc, argv, "p:r:")) != -1)
        switch (c)
    {
        case 'r':
            ROOT = malloc(strlen(optarg));
            strcpy(ROOT,optarg);
            break;
        case 'p':
            strcpy(PORT,optarg);
            break;
        case '?':
            fprintf(stderr,"Wrong arguments given!!!\n");
            exit(1);
        default:
            exit(1);
    }
    
    printf("Server started at port no. %s%s%s with root directory as %s%s%s\n","\033[92m",PORT,"\033[0m","\033[92m",ROOT,"\033[0m");
    // Setting all elements to -1: signifies there is no client connected
    int i;
    for (i=0; i<CONNMAX; i++)
        clients[i]=-1;
    startServer(PORT);
    
    // ACCEPT connections
    while (1)
    {
	int connection;
        addrlen = sizeof(clientaddr);
        connection = accept (listenfd, (struct sockaddr *) &clientaddr, &addrlen);
        
        if (connection < 0)
            error ("accept() error");
        else
        {
            if ( fork()==0 )
            {
                respond(connection);
                exit(0);
            }
        }
        
    }
    
    return 0;
}

//start server
void startServer(char *port)
{
    struct addrinfo hints, *res, *p;
    
    // getaddrinfo for host
    memset (&hints, 0, sizeof(hints));
    hints.ai_family = AF_INET;
    hints.ai_socktype = SOCK_STREAM;
    hints.ai_flags = AI_PASSIVE;
    if (getaddrinfo( NULL, port, &hints, &res) != 0)
    {
        perror ("getaddrinfo() error");
        exit(1);
    }
    // socket and bind
    for (p = res; p!=NULL; p=p->ai_next)
    {
        listenfd = socket (p->ai_family, p->ai_socktype, 0);
        if (listenfd == -1) continue;
        if (bind(listenfd, p->ai_addr, p->ai_addrlen) == 0) break;
    }
    if (p==NULL)
    {
        perror ("socket() or bind()");
        exit(1);
    }
    
    freeaddrinfo(res);
    
    // listen for incoming connections
    if ( listen (listenfd, 1000000) != 0 )
    {
        perror("listen() error");
        exit(1);
    }
}

//client connection
void respond(int conn_fd)
{
    char message[MAX_SIZE], raw_input[INPUT_BUF];
    int rcvd;
    char connstr[55];
    char numBytesStr[11];
    unsigned int numBytes;

    // print formatted output to connstr
    sprintf(connstr, "Connection Id: %d. How long is your message (in bytes)?\n", conn_fd); 

    printf("conn_fd: %d\n", conn_fd);
    write(conn_fd, connstr, 55);

    rcvd = read(conn_fd, numBytesStr, 11);
    if (rcvd > 10) { // truncate if more than 10 characters were read
        rcvd = 10;
    }
    numBytesStr[rcvd] = '\0';
    printf("numBytesStr: %s\n", numBytesStr);
    sscanf(numBytesStr, "%d\n", &numBytes);
    if (numBytes + 1 > MAX_SIZE) {
	write(conn_fd, "Sorry, that is too long\n", 24);
	fprintf(stderr, "%d is greater than %d\n", numBytes, MAX_SIZE);
    	//Closing SOCKET
    	shutdown (conn_fd, SHUT_RDWR);  //All further send and recieve operations are DISABLED...
    	close(conn_fd);
    }
    else {
    	write(conn_fd, "Enter your message\n", 19);

    	memset( (void*)raw_input, (int)'\0', INPUT_BUF);
		
	int bytesToRead = numBytes % INPUT_BUF;
	printf("bytes to read: %d\n", bytesToRead);
    	rcvd = read(conn_fd, raw_input, bytesToRead);
    	printf("bytes received: %d\n", rcvd);
    	
	if (rcvd<0)    // receive error
        	fprintf(stderr,"recv() error %s\n", strerror(errno));
    	else if (rcvd==0)    // receive socket closed
        	fprintf(stderr,"Client disconnected unexpectedly.\n");
    	else    // message received
    	{
        	memcpy(message, raw_input, rcvd);
    	}
    }

}

__attribute__ ((naked)) void poprdx() {
	asm("pop %rdx; ret");
}
